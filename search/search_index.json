{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation : https://matthewwardrop.github.io/spec-classes Source Code : https://github.com/matthewwardrop/spec-classes Issue tracker : https://github.com/matthewwardrop/spec-classes/issues Introduction \u00b6 spec_classes is a stand-alone (but largely interoperable) generalization of the standard library's dataclass decorator. It adds, among other things: type-checking, rich field preparation, and convenient copy-on-write mutation wrappers. Spec-class definitions are Pythonic, simple, and concise. This library is especially useful in contexts where run-time validation and instant feedback is desirable, and/or where correctness is valued over performance. With that said, we do try to keep spec-classes performant (see performance details ). Philosophy \u00b6 It should be hard for users to do the wrong thing. spec_classes is designed to help end-users interact with, mutate, and assemble (especially in ad hoc contexts like notebooks) potentially large libraries of data classes without fear of breaking things. Operations on data classes should be atomic (operations should never be partially committed), validated (types should match, etc.), and provide instant helpful feedback when the user makes a mistake. We don't own your class. spec_classes never overrides local pre-existing methods, and doesn't add any metaclasses or parents. If you decorate a class with @spec_class , spec classes will add (if you have not already) some dunder magic methods (like __init__ , __setattr__ , etc.), and some helper methods... but that's it. Spec classes are, at the end of the day, just regular classes pre-loaded with useful methods that you didn't have to write yourself. Copy-on-write by default. One of the dangers with using class instances as specification is that if they are mutated in one context, they are mutated for all contexts. Spec classes does not prevent (by default) local mutations of class instances (you can still do my_spec.foo = 'bar' ); but all helper methods return a mutated copy by default. For example, my_spec.with_foo('bar') will not be the same instance as my_spec , and so these methods are always safe to use. Be consistent. All helper methods added by spec_classes exist within well defined namespaces; that is: with_<attr> , transform_<attr> , etc.; and each class of methods has the same naming conventions for arguments and provides complete inline documentation. This makes it easy for users to figure out how to use the methods, to override these methods and/or to add new methods that do not collide. Minimize Surprise. The behavior of spec classes almost always matches that of base Python classes where functionality overlaps, and should always be intuitive otherwise (e.g. when type-checking is violated). Performance is important. Although performance is not the primary goal of spec_classes , given the targeted feature-set, the overhead introduced should be as small as possible. Example \u00b6 from spec_classes import spec_class @spec_class class Rectangle : width : float height : float color : str @property def area ( self ): return self . width * self . height rect = Rectangle () rect # Rectangle(width=MISSING, height=MISSING, color=MISSING) rect . update ( width = 10. , height = 12. ) . with_color ( \"red\" ) # Rectangle(width=10.0, height=12.0, color='red') Rectangle ( width = 10. , height = 10. ) . area # 100.0 rect . with_width ( 'invalid' ) # TypeError: Attempt to set `Rectangle.width` with an invalid type [got `'invalid'`; expecting `float`]. For more details on usage, refer to the documentation . Installation \u00b6 Spec classes can be installed via pip or conda . To install via pip you can use: pip install spec-classes To install via conda you can use: conda install spec-classes You can verify that the installation was successful by printing the version of spec-classes that was installed: python -c \"import spec_classes; print(spec_classes.__version__)\" Related projects and prior art \u00b6 spec_classes takes a more opinionated stance than most libraries in this space on exactly how data-classes should be built and mutated. Nevertheless, there are excellent pre-existing alternatives to spec-classes for those looking for something lighter-weight. In particular, you could consider: typeguard : A utility library for run-time type-checking functions, methods and classes. pytypes : Another utility library for run-time type-checking functions, methods and classes. pydantic : A light-weight data parsing and validation library that also uses type hints. attrs : A library that provides a super-set of the functionality of Python's data-class, but still adds no run-time overhead (no type-checking, extra helper-methods, etc). There are many other libraries in the business of mapping and validating transformations from JSON to Python classes, but these are somewhat orthogonal to the aims of this project (which is to make Python classes themselves pleasant to use), and so they are not included here.","title":"Introduction"},{"location":"#introduction","text":"spec_classes is a stand-alone (but largely interoperable) generalization of the standard library's dataclass decorator. It adds, among other things: type-checking, rich field preparation, and convenient copy-on-write mutation wrappers. Spec-class definitions are Pythonic, simple, and concise. This library is especially useful in contexts where run-time validation and instant feedback is desirable, and/or where correctness is valued over performance. With that said, we do try to keep spec-classes performant (see performance details ).","title":"Introduction"},{"location":"#philosophy","text":"It should be hard for users to do the wrong thing. spec_classes is designed to help end-users interact with, mutate, and assemble (especially in ad hoc contexts like notebooks) potentially large libraries of data classes without fear of breaking things. Operations on data classes should be atomic (operations should never be partially committed), validated (types should match, etc.), and provide instant helpful feedback when the user makes a mistake. We don't own your class. spec_classes never overrides local pre-existing methods, and doesn't add any metaclasses or parents. If you decorate a class with @spec_class , spec classes will add (if you have not already) some dunder magic methods (like __init__ , __setattr__ , etc.), and some helper methods... but that's it. Spec classes are, at the end of the day, just regular classes pre-loaded with useful methods that you didn't have to write yourself. Copy-on-write by default. One of the dangers with using class instances as specification is that if they are mutated in one context, they are mutated for all contexts. Spec classes does not prevent (by default) local mutations of class instances (you can still do my_spec.foo = 'bar' ); but all helper methods return a mutated copy by default. For example, my_spec.with_foo('bar') will not be the same instance as my_spec , and so these methods are always safe to use. Be consistent. All helper methods added by spec_classes exist within well defined namespaces; that is: with_<attr> , transform_<attr> , etc.; and each class of methods has the same naming conventions for arguments and provides complete inline documentation. This makes it easy for users to figure out how to use the methods, to override these methods and/or to add new methods that do not collide. Minimize Surprise. The behavior of spec classes almost always matches that of base Python classes where functionality overlaps, and should always be intuitive otherwise (e.g. when type-checking is violated). Performance is important. Although performance is not the primary goal of spec_classes , given the targeted feature-set, the overhead introduced should be as small as possible.","title":"Philosophy"},{"location":"#example","text":"from spec_classes import spec_class @spec_class class Rectangle : width : float height : float color : str @property def area ( self ): return self . width * self . height rect = Rectangle () rect # Rectangle(width=MISSING, height=MISSING, color=MISSING) rect . update ( width = 10. , height = 12. ) . with_color ( \"red\" ) # Rectangle(width=10.0, height=12.0, color='red') Rectangle ( width = 10. , height = 10. ) . area # 100.0 rect . with_width ( 'invalid' ) # TypeError: Attempt to set `Rectangle.width` with an invalid type [got `'invalid'`; expecting `float`]. For more details on usage, refer to the documentation .","title":"Example"},{"location":"#installation","text":"Spec classes can be installed via pip or conda . To install via pip you can use: pip install spec-classes To install via conda you can use: conda install spec-classes You can verify that the installation was successful by printing the version of spec-classes that was installed: python -c \"import spec_classes; print(spec_classes.__version__)\"","title":"Installation"},{"location":"#related-projects-and-prior-art","text":"spec_classes takes a more opinionated stance than most libraries in this space on exactly how data-classes should be built and mutated. Nevertheless, there are excellent pre-existing alternatives to spec-classes for those looking for something lighter-weight. In particular, you could consider: typeguard : A utility library for run-time type-checking functions, methods and classes. pytypes : Another utility library for run-time type-checking functions, methods and classes. pydantic : A light-weight data parsing and validation library that also uses type hints. attrs : A library that provides a super-set of the functionality of Python's data-class, but still adds no run-time overhead (no type-checking, extra helper-methods, etc). There are many other libraries in the business of mapping and validating transformations from JSON to Python classes, but these are somewhat orthogonal to the aims of this project (which is to make Python classes themselves pleasant to use), and so they are not included here.","title":"Related projects and prior art"},{"location":"examples/","text":"This section of the documentation provides some concrete examples for how you can use spec_classes in the real world. It is intended to allow you to get a quick sense of spec_classes 's capabilities, and to act as a quick-start guide for the impatient. For more thorough usage documentation, refer to Usage .","title":"Overview"},{"location":"examples/basic/","text":"Let's start simple. Here's a basic spec-class: from spec_classes import spec_class @spec_class class Door : width : float height : float color : str We can instantiate it: Door () # Door(width=MISSING, height=MISSING, color=MISSING) Door ( color = 'red' ) # Door(width=MISSING, height=MISSING, color='red') Mutate it (copy-on-write): d = Door () ( d . with_width ( 5.3 ) . with_height ( 10.4 ) . with_color ( 'red' ) ) # Door(width=5.3, height=10.4, color='red') d # Door(width=MISSING, height=MISSING, color=MISSING) d . with_width ( 5.3 , _inplace = True ) d # Door(width=5.3, height=MISSING, color=MISSING) Transform it: ( Door ( width = 2. ) . transform_width ( lambda width : 2 * width ) ) # Door(width=4.0, height=MISSING, color=MISSING) Reset it: ( Door ( width = 2. ) . reset_width () ) # Door(width=MISSING, height=MISSING, color=MISSING) But... we can't do the wrong thing: Door ( width = 'invalid' ) # TypeError: Attempt to set `Door.width` with an invalid type [got `'invalid'`; expecting `float`].","title":"Basic"},{"location":"examples/collections/","text":"Here's a spec-class with collections. from spec_classes import spec_class from typing import List @spec_class class Number : einstein_approved : bool = False value : int @spec_class class FavoriteNumbers : numbers : List [ Number ] = [] We can instantiate it: FavoriteNumbers () # FavoriteNumbers(numbers=[]) FavoriteNumbers ( numbers = [ Number ( value = 10 ), Number ( value = 13 , einstein_approved = True )]) # FavoriteNumbers( # numbers=[ # Number( # einstein_approved=False, # value=10 # ), # Number( # einstein_approved=True, # value=13 # ) # ] # ) We can extend and mutate it: ( FavoriteNumbers () . with_number ( value = 26 , einstein_approved = True ) # FavoriteNumbers(numbers=[Number(einstein_approved=True, value=26)]) . transform_number ( 0 , value = lambda value : value * 2 ) # FavoriteNumbers(numbers=[Number(einstein_approved=True, value=52)]) . without_number ( 0 ) ) # FavoriteNumbers(numbers=[]) Similar methods exist for dictionary and set collections also; see Collections Usage .","title":"Collections"},{"location":"examples/dataclasses/","text":"Spec-classes are interoperable with dataclasses, and data-class definitions can be easily upgraded into spec-class ones. Here's a dataclass definition: from dataclasses import dataclass , field @dataclass class Farm : owner : str = \"Harry\" animals : List [ str ] = field ( default_factory = list ) f = Farm () f # Farm(owner='Harry', animals=[]) # We're not protected here from any abuse of types at run-time. f . owner = 10 f # Farm(owner=10, animals=[]) Let's upgrade that to a spec-class the easiest possible way: from spec_classes import spec_class from dataclasses import field @spec_class class Farm : owner : str = \"Harry\" animals : List [ str ] = field ( default_factory = list ) f = Farm () f # Farm(owner='Harry', animals=[]) # Looks the same! But now we're enforcing types. f . owner = 10 # TypeError: Attempt to set `Farm.owner` with an invalid type [got `10`; expecting `str`]. Spec-classes also has its own equivalent of field that provides some additional spec-classes specific configuration (see Attr ), so the above is equivalent to: from spec_classes import spec_class , Attr @spec_class class Farm : owner : str = \"Harry\" animals : List [ str ] = Attr ( default_factory = list ) Spec-classes is also special in that it allows mutable types to be set as the defaults on base class definition (they are safely copied at instantiation time in the generated constructor). Thus, you can actually just write: from spec_classes import spec_class @spec_class class Farm : owner : str = \"Harry\" animals : List [ str ] = [] Boom! Done.","title":"Dataclass Interoperability"},{"location":"examples/preparation/","text":"Sometimes you need to do some type-casting in order to get incoming values to conform the right types. Sometimes this is done in the constructor ( __init__ ) or via properties... but in spec-classes this is made much more explicit and concise. Here's an example: from spec_classes import spec_class from typing import Any , Union @spec_class class BinaryNumbers : are_cool : bool numbers : List [ str ] def _prepare_are_cool ( self , are_cool : Any ) -> bool : return bool ( are_cool ) def _prepare_number ( self , number : Union [ str , int ]) -> bool : if isinstance ( number , int ): return \" {0:b} \" . format ( number ) if set ( number ) . difference ({ \"0\" , \"1\" }): raise TypeError ( f \"Incoming string ` { repr ( number ) } ` is not a valid binary number.\" ) return number BinaryNumbers ( are_cool = 1 , numbers = [ '01001' , 10 ]) # BinaryNumbers(are_cool=True, numbers=['01001', '1010']) BinaryNumbers () . with_number ( '3213' ) # TypeError: Incoming string `'3213'` is not a valid binary number. As you can see, _prepare_<attr> and _prepare_<attr_singular> are detected as preparation/typecasting methods. You can also explicitly associate attributes with methods/functions ala. Python properties using: from spec_classes import spec_class , Attr from typing import Any , Union @spec_class class BinaryNumbers : are_cool : bool = Attr () numbers : List [ str ] = Attr () @are_cool . preparer def _ ( self , are_cool ): return bool ( are_cool ) @numbers . item_preparer def _ ( self , number ): if isinstance ( number , int ): return \" {0:b} \" . format ( number ) if set ( number ) . difference ({ \"0\" , \"1\" }): raise TypeError ( f \"Incoming string ` { repr ( number ) } ` is not a valid binary number.\" ) return number","title":"Preparation/Typecasting"},{"location":"implementation/how_it_works/","text":"While the best way to understand how spec-classes works is to look at the code, this section of the documentation provides a high-level overview of how things fit together so that looking at the code is less daunting. At the end of the day, all that spec-classes does is add a few extra methods to a class to make it behave in a consistent and convenient manner. Exactly which methods get added depends on what is already implemented by the user (it never clobbers user-specified methods), and the type of attribute for which methods are being added (e.g. collection attributes). The functionality of these methods can be broken down into two categories: Magic methods that perform type-checking and value preparation/type-casting. Regular methods that help with copy-on-write/builder-pattern mutations. We'll deal with these separately below, but all methods added by spec-classes are defined in spec_classes.methods . Rather than directly adding functions to the class, we add MethodDescriptor instances that lazily generate the helper methods as they are required, and then replace themselves with the actual implementation (except for magic methods which we pre-materialize from the descriptors), reducing unnecessary overhead and allowing the code to be more modular and extensible. Most methods are generated by spec_classes.utils.method_builder.MethodBuilder , which allows us to build methods with useful generated documentation (including type-annotations) that users can introspect using standard help() calls. Apart from the methods themselves, you should also know that all spec-class specific metadata is stored in a SpecClassMetadata instance as the __spec_class__ attribute of a spec-class. This is regularly used by methods to tailor their behaviour to the method being mutated. Magic Methods \u00b6 The Python data model is very rich and allows for any class to customize all aspects of a class' life-cycle using double-underscore (aka. \"dunder\") or \"magic\" methods. Spec-classes leverages this data-model to intercept certain class instance operations. All magic methods are implemented in spec_classes.methods.core The most important magic method is __setattr__ , which is exploited to validate incoming values at run-time. In practice this method is defined such that calls to __setattr__ are redirected to the equivalent of calling the .with_<attr> helper method so that direct attribute mutation follows the same logic as the helper methods (except that mutations are done in-place by default). This results in all values being type-checked (unless disabled explicitly by some parameterization of the code pathway). Attributes that are not managed by spec-classes are passed through to the default implementation of __setattr__ . Another very important magic method is __init__ , which is the default instance constructor for Python classes. The implementation provided by spec-classes ensures that every attribute is set correctly and is mutation safe, and respects any constructor implementations defined on super classes. The other methods implemented by spec-classes are: __eq__ : Checks for equality of two instances of a spec-classes. __repr__ : Provides a human-friendly representation of the spec-class state. __getattr__ : A light-weight implementation that raises a user-friendly error if a managed spec-class attribute does not yet have a value, but otherwise introduces no new functionality. __delattr__ : Deleting an attribute on a class instance should remove local attributes and unmask the base class attribute (if it exists). In spec-classes this is achieved by resetting the attribute to its original default value. __deepcopy__ : During non-inplace mutations, spec-classes copies the entire class using copy.deepcopy . This magic method customizes the copying behavior to respect the options set on the spec-class. Helper methods \u00b6 The helper method implementations are pretty straight-forward. The scalar methods are defined in spec_classes.methods.scalar , and the collection-specific methods in spec_classes.methods.collections . All of these methods use the low level mutate_attr and mutate_value methods defined in spec_classes.utils.mutation . Stitching it all together \u00b6 The main logic that stitches together the right metadata and methods is contained within the spec_class decorator . It is implemented as a class so that users can subclass it downsteam, and to keep the logic in smaller understandable chunks. This body of code is also responsible for setting up the deferred bootstrapping (if necessary).","title":"How It Works"},{"location":"implementation/how_it_works/#magic-methods","text":"The Python data model is very rich and allows for any class to customize all aspects of a class' life-cycle using double-underscore (aka. \"dunder\") or \"magic\" methods. Spec-classes leverages this data-model to intercept certain class instance operations. All magic methods are implemented in spec_classes.methods.core The most important magic method is __setattr__ , which is exploited to validate incoming values at run-time. In practice this method is defined such that calls to __setattr__ are redirected to the equivalent of calling the .with_<attr> helper method so that direct attribute mutation follows the same logic as the helper methods (except that mutations are done in-place by default). This results in all values being type-checked (unless disabled explicitly by some parameterization of the code pathway). Attributes that are not managed by spec-classes are passed through to the default implementation of __setattr__ . Another very important magic method is __init__ , which is the default instance constructor for Python classes. The implementation provided by spec-classes ensures that every attribute is set correctly and is mutation safe, and respects any constructor implementations defined on super classes. The other methods implemented by spec-classes are: __eq__ : Checks for equality of two instances of a spec-classes. __repr__ : Provides a human-friendly representation of the spec-class state. __getattr__ : A light-weight implementation that raises a user-friendly error if a managed spec-class attribute does not yet have a value, but otherwise introduces no new functionality. __delattr__ : Deleting an attribute on a class instance should remove local attributes and unmask the base class attribute (if it exists). In spec-classes this is achieved by resetting the attribute to its original default value. __deepcopy__ : During non-inplace mutations, spec-classes copies the entire class using copy.deepcopy . This magic method customizes the copying behavior to respect the options set on the spec-class.","title":"Magic Methods"},{"location":"implementation/how_it_works/#helper-methods","text":"The helper method implementations are pretty straight-forward. The scalar methods are defined in spec_classes.methods.scalar , and the collection-specific methods in spec_classes.methods.collections . All of these methods use the low level mutate_attr and mutate_value methods defined in spec_classes.utils.mutation .","title":"Helper methods"},{"location":"implementation/how_it_works/#stitching-it-all-together","text":"The main logic that stitches together the right metadata and methods is contained within the spec_class decorator . It is implemented as a class so that users can subclass it downsteam, and to keep the logic in smaller understandable chunks. This body of code is also responsible for setting up the deferred bootstrapping (if necessary).","title":"Stitching it all together"},{"location":"implementation/performance/","text":"The additional functionality provided by spec-classes is not free, but effort is made to keep things as performant as possible. In the following we briefly investigate the relative performance of spec-classes to raw classes and data-classes. Let's define three classes, one using dataclass, one with a trivial __setattr__ implementation, and one using spec-classes. from dataclasses import dataclass from spec_classes import spec_class @dataclass class MyData : \"\"\" Basic data class. No `__setattr__` is implemented, so things stay mostly in C. \"\"\" a : int = 1 b : int = 2 c : int = 3 @dataclass class MyDataRaw : \"\"\" Basic data class with trivial `__setattr__` implementation. \"\"\" a : int = 1 b : int = 2 c : int = 3 def __setattr__ ( self , attr , value ): super () . __setattr__ ( attr , value ) @spec_class ( bootstrap = True ) class MySpec : \"\"\" Simple spec-class, which enforces types at runtime. \"\"\" a : int = 1 b : int = 2 c : int = 3 Without any attempt to be scientific and exact in the performance comparisons, here is a simple benchmark for instantiating these classes (on spec-classes version 1.0.1): % timeit MyData ( a = 1 , b = 2 , c = 3 ) # 330 ns \u00b1 11.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit MyDataRaw ( a = 1 , b = 2 , c = 3 ) # 1.02 \u00b5s \u00b1 44 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit MySpec ( a = 1 , b = 2 , c = 3 ) # 7.88 \u00b5s \u00b1 310 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each) Roughly speaking, then, spec-classes is about 23 times slower than when using the basic class behavior (implemented in C); or about 8 times slower than when using the basic class behavior but with a trivial Python __setattr__ wrapper. Obviously this overhead will increase when using other more advanced features of spec-classes, such as the attribute preparers, but you should expect the overhead to be roughly commensurate with the performance overhead of implementing it outside of spec-classes. While this overhead is non-trivial, for the use-case for which it is designed (where there is a human-sensible number of classes to mutate and configure), this overhead is acceptable. In the future, we may add support for disabling type-checking and/or other enforcements, which may allow us to reduce this overhead further.","title":"Performance Implications"},{"location":"usage/","text":"This section of the documentation is an introduction to the practical use of spec_classes . If you are interested in deeply understanding spec-classes, it is recommended you read the following subsections in order, as each subsection assumes knowledge introduced previously. If you only want a quick sense of what spec-classes look like, please refer to the Examples section. Note This documentation is predominantly targeted at developers integrating spec-classes into their project(s). Spec classes are designed to be intuitive, and generated helper methods have fairly thorough documentation that users can access using help(<class/instance>.<helper_method>) . As such, while users of classes generated using spec-classes may find this documentation useful, they are likely to get nearly as much value out of just inspecting the spec class instances interactively. Once you are familiar with how spec classes work in practice, feel free to move on to the Implementation Details section if you are interested in understanding how things are implemented under the hood, tips for integrating it into your projects, and/or the performance considerations of doing so.","title":"Overview"},{"location":"usage/advanced/","text":"Post init or copy hooks \u00b6 If you want to run some code immediately after instantiation or after you spec-class is (deep-)copied, you can implement the __post_init__() and __post_copy()__ methods respectively. @spec_class class MySpec : def __post_init__ ( self ): self . __copy_count = 0 def __post_copy__ ( self ): self . __copy_count += 1 Typecasting/preparation \u00b6 While preparation of attribute values can still be done using custom constructors or property overrides, spec-classes provides a simpler mechanism for typecasting/preparing attribute values (as shown in one of the examples ). The Attr object has two optional attributes: prepare and prepare_item . Both of these should be Callable objects if provided, and are respectively used to prepare the attribute value and items within an attribute collection. When both are present, prepare is called first. There are two ways to populate these attributes: by providing a _prepare_<attr> and/or a _prepare_<attr_singular> method; or by setting the attribute to an Attr instance and using the Attr.preparer and Attr.item_preparer decorators. Both are demonstrated in the aforementioned example . Init overflow attributes \u00b6 If you want your spec-class to accept arbitrary arguments in its constructor, including those that are not registered attributes, you can pass an arbitrary attribute name to init_overflow_attr in the spec_class decorator. During instance construction, spec-classes will then collect all additional keyword arguments and place them as a dictionary in nominated attribute. @spec_class ( init_overflow_attr = 'kwargs' ) class Spec : pass Spec ( a = 1 , b = 2 ) # Spec(kwargs={'a': 1, 'b': 2}) Frozen spec classes \u00b6 By default, instances of spec-classes behave much like any other instance in that you can mutate attributes in-place. If you would like to prevent in-place mutation, you can use the frozen keyword argument to the constructor. For example: @spec_class ( frozen = True ) class MyClass : my_str : str MyClass () . my_str = \"hi\" # FrozenInstanceError: Cannot mutate attribute `my_str` of frozen spec class `MySpec`. Note Frozen spec class instances can still be updated using the copy-on-write helper methods (introduced below): MySpec () . with_my_str ( \"hi\" ) # MyClass(my_str=\"hi\") Avoiding copies of large attributes \u00b6 Spec-classes adopt a copy-on-write approach when mutating classes via the helper methods (e.g. .with_<attr>() ). In some instances, however, that is undesirable, for example when one or more attributes consumes a lot of memory. To help with this, spec-classes allows entire spec-classes and/or attributes thereof to opt-out of being copied. When decorating a spec-class you can pass do_not_copy=True to spec_class to disable all copying (effectively making all mutations in-place), or pass do_not_copy=['attributes', 'to', 'avoid', 'copying'] , which will populate the Attr attribute do_not_copy for the nominated attributes, and pass these attributes by reference (rather than value) when copying spec-classes. You can also directly specify attributes to using Attr , as documented here . @spec_class ( do_not_copy = [ 'data' ]) class DataAnalyzer : data : Any # Potentially LARGE data object another_obj : Any = Attr ( do_not_copy = True ) Immediate bootstrapping \u00b6 Spec-classes is typically lazy in its \"bootstrapping\" of classes (it doesn't actually mutate the class straight away with all of the helper methods). This is because it is often the case that type-annotated code becomes cyclic very quickly, and since spec-classes needs type information during the generation of methods, immediately bootstrapping would cause cyclic import issues. Instead, spec-classes adds a __new__ method and a placeholder __spec_class__ metadata, and lazily bootstraps until the first instantiation or the first lookup of the __spec_class__ attribute. In the vast majority of cases, this works well, but it is possible that more advanced class introspections require the class to be bootstrapped immediately. You can achieve this by passing bootstrap=True to the spec_class decorator. @spec_class ( bootstrap = True ) class Spec : ... Avoiding cyclic import issues \u00b6 As mentioned above, cyclic import issues are common in type-annotated code, especially if the type annotations are required at run-time (as is the case for spec-classes). Sometimes there is just no way to import the types necessary at a module level without having all classes in a single file. To avoid this, spec-classes allows you to lazily import types that are used to annotate attributes by importing them in a method that is only evaluated immediately before the types are used. You can also use this mechanism to alias types. from __future__ import annotations @spec_class class Spec : data : DataFrame value : my_alias @classmethod def ANNOTATION_TYPES ( cls ): import pandas return { 'DataFrame' : pandas . DataFrame , 'my_alias' : str , } Overriding dunder methods \u00b6 The dunder methods that spec-classes introduces are: __init__ , __repr__ , __eq__ , __getattr__ , __setattr__ , __delattr__ and __deepcopy__ . Overriding __getattr__ , __setattr__ , __delattr__ and __deepcopy__ is not supported (they are essential for the behavior of spec-classes), and you will be responsible for making things work properly if you do. __init__ , __repr__ and __eq__ can be overridden safely, however. In the rare circumstances that it becomes necessary for you to overwrite these methods, you can just implement these on the class. Since spec-classes never overwrites methods that a user has written, these methods will not be overridden by spec-classes. If you want to completely remove these methods, you can pass init=False , repr=False and/or eq=False to the spec_class decorator. For your convenience, spec-classes will always register spec-classes' implementation of these methods as __spec_class_init__ , __spec_class_repr__ and __spec_class_eq__ so that you can leverage them in your overrides (this is necessary because spec-classes does not touch your classes' MRO, and so no super() calls to spec-classes' methods are possible). Subclassing \u00b6 Spec-classes fully supports subclassing, including the honoring of overridden constructors in super-classes. Spec-classes remembers where spec-class attributes were defined, and calls the appropriate constructor to initialize them. For example: @spec_class class Base : x : int y : int def __init__ ( self , x = 10 , y = 10 ): self . x = x + 1 self . y = y + 1 self . a = x * y @spec_class class Sub ( Base ): x = 100 # Sub provides a new default value but is not the owner of `x` y : int = 100 # Sub becomes the owner of `y` z : int = 300 Sub () # Sub(x=101, y=100, z=300) Sub () . a # 1000 # (x = 100) * (y = 10), since parent constructors are only passed # attributes they own.","title":"Advanced Usage"},{"location":"usage/advanced/#post-init-or-copy-hooks","text":"If you want to run some code immediately after instantiation or after you spec-class is (deep-)copied, you can implement the __post_init__() and __post_copy()__ methods respectively. @spec_class class MySpec : def __post_init__ ( self ): self . __copy_count = 0 def __post_copy__ ( self ): self . __copy_count += 1","title":"Post init or copy hooks"},{"location":"usage/advanced/#typecastingpreparation","text":"While preparation of attribute values can still be done using custom constructors or property overrides, spec-classes provides a simpler mechanism for typecasting/preparing attribute values (as shown in one of the examples ). The Attr object has two optional attributes: prepare and prepare_item . Both of these should be Callable objects if provided, and are respectively used to prepare the attribute value and items within an attribute collection. When both are present, prepare is called first. There are two ways to populate these attributes: by providing a _prepare_<attr> and/or a _prepare_<attr_singular> method; or by setting the attribute to an Attr instance and using the Attr.preparer and Attr.item_preparer decorators. Both are demonstrated in the aforementioned example .","title":"Typecasting/preparation"},{"location":"usage/advanced/#init-overflow-attributes","text":"If you want your spec-class to accept arbitrary arguments in its constructor, including those that are not registered attributes, you can pass an arbitrary attribute name to init_overflow_attr in the spec_class decorator. During instance construction, spec-classes will then collect all additional keyword arguments and place them as a dictionary in nominated attribute. @spec_class ( init_overflow_attr = 'kwargs' ) class Spec : pass Spec ( a = 1 , b = 2 ) # Spec(kwargs={'a': 1, 'b': 2})","title":"Init overflow attributes"},{"location":"usage/advanced/#frozen-spec-classes","text":"By default, instances of spec-classes behave much like any other instance in that you can mutate attributes in-place. If you would like to prevent in-place mutation, you can use the frozen keyword argument to the constructor. For example: @spec_class ( frozen = True ) class MyClass : my_str : str MyClass () . my_str = \"hi\" # FrozenInstanceError: Cannot mutate attribute `my_str` of frozen spec class `MySpec`. Note Frozen spec class instances can still be updated using the copy-on-write helper methods (introduced below): MySpec () . with_my_str ( \"hi\" ) # MyClass(my_str=\"hi\")","title":"Frozen spec classes"},{"location":"usage/advanced/#avoiding-copies-of-large-attributes","text":"Spec-classes adopt a copy-on-write approach when mutating classes via the helper methods (e.g. .with_<attr>() ). In some instances, however, that is undesirable, for example when one or more attributes consumes a lot of memory. To help with this, spec-classes allows entire spec-classes and/or attributes thereof to opt-out of being copied. When decorating a spec-class you can pass do_not_copy=True to spec_class to disable all copying (effectively making all mutations in-place), or pass do_not_copy=['attributes', 'to', 'avoid', 'copying'] , which will populate the Attr attribute do_not_copy for the nominated attributes, and pass these attributes by reference (rather than value) when copying spec-classes. You can also directly specify attributes to using Attr , as documented here . @spec_class ( do_not_copy = [ 'data' ]) class DataAnalyzer : data : Any # Potentially LARGE data object another_obj : Any = Attr ( do_not_copy = True )","title":"Avoiding copies of large attributes"},{"location":"usage/advanced/#immediate-bootstrapping","text":"Spec-classes is typically lazy in its \"bootstrapping\" of classes (it doesn't actually mutate the class straight away with all of the helper methods). This is because it is often the case that type-annotated code becomes cyclic very quickly, and since spec-classes needs type information during the generation of methods, immediately bootstrapping would cause cyclic import issues. Instead, spec-classes adds a __new__ method and a placeholder __spec_class__ metadata, and lazily bootstraps until the first instantiation or the first lookup of the __spec_class__ attribute. In the vast majority of cases, this works well, but it is possible that more advanced class introspections require the class to be bootstrapped immediately. You can achieve this by passing bootstrap=True to the spec_class decorator. @spec_class ( bootstrap = True ) class Spec : ...","title":"Immediate bootstrapping"},{"location":"usage/advanced/#avoiding-cyclic-import-issues","text":"As mentioned above, cyclic import issues are common in type-annotated code, especially if the type annotations are required at run-time (as is the case for spec-classes). Sometimes there is just no way to import the types necessary at a module level without having all classes in a single file. To avoid this, spec-classes allows you to lazily import types that are used to annotate attributes by importing them in a method that is only evaluated immediately before the types are used. You can also use this mechanism to alias types. from __future__ import annotations @spec_class class Spec : data : DataFrame value : my_alias @classmethod def ANNOTATION_TYPES ( cls ): import pandas return { 'DataFrame' : pandas . DataFrame , 'my_alias' : str , }","title":"Avoiding cyclic import issues"},{"location":"usage/advanced/#overriding-dunder-methods","text":"The dunder methods that spec-classes introduces are: __init__ , __repr__ , __eq__ , __getattr__ , __setattr__ , __delattr__ and __deepcopy__ . Overriding __getattr__ , __setattr__ , __delattr__ and __deepcopy__ is not supported (they are essential for the behavior of spec-classes), and you will be responsible for making things work properly if you do. __init__ , __repr__ and __eq__ can be overridden safely, however. In the rare circumstances that it becomes necessary for you to overwrite these methods, you can just implement these on the class. Since spec-classes never overwrites methods that a user has written, these methods will not be overridden by spec-classes. If you want to completely remove these methods, you can pass init=False , repr=False and/or eq=False to the spec_class decorator. For your convenience, spec-classes will always register spec-classes' implementation of these methods as __spec_class_init__ , __spec_class_repr__ and __spec_class_eq__ so that you can leverage them in your overrides (this is necessary because spec-classes does not touch your classes' MRO, and so no super() calls to spec-classes' methods are possible).","title":"Overriding dunder methods"},{"location":"usage/advanced/#subclassing","text":"Spec-classes fully supports subclassing, including the honoring of overridden constructors in super-classes. Spec-classes remembers where spec-class attributes were defined, and calls the appropriate constructor to initialize them. For example: @spec_class class Base : x : int y : int def __init__ ( self , x = 10 , y = 10 ): self . x = x + 1 self . y = y + 1 self . a = x * y @spec_class class Sub ( Base ): x = 100 # Sub provides a new default value but is not the owner of `x` y : int = 100 # Sub becomes the owner of `y` z : int = 300 Sub () # Sub(x=101, y=100, z=300) Sub () . a # 1000 # (x = 100) * (y = 10), since parent constructors are only passed # attributes they own.","title":"Subclassing"},{"location":"usage/basic/","text":"The spec_class decorator \u00b6 The primary entry-point into spec_classes is the spec_class decorator, which takes your standard class and converts it into a \"spec-class\" (\ud83c\udf1f ooh... shiny! \ud83c\udf1f). In practice, this just means that it adds some dunder magic methods like __init__ and __setattr__ , along with a few helper methods ... and nothing else. This is intentionally very similar to the standard library's dataclass , and indeed you can largely consider spec-classes to be a generalization of it. Using spec-classes is as simple as decorating your annotated class with spec_class . For example: from spec_classes import spec_class @spec_class class MySpec : my_str : str The result is a class that: Thoroughly type-checks class attributes whenever and however they are mutated. Has helper methods that assist with the mutation of annotated attributes, allowing one to adopt copy-on-write workflows (see below for more details). Knows how to output a human-friendly representation of the spec class when printed. Knows how to compare itself with other instances of the spec class. As such, and with a huge amount of simplification, the above spec-class declaration would be roughly similar to writing something like: import copy from spec_classes import MISSING class MySpec : def __init__ ( self , my_str = MISSING ) if my_str is not MISSING : self . my_str = my_str def __repr__ ( self ): return f \"MySpec(my_str= { getattr ( self , 'my_str' , MISSING ) } \" ) def __eq__ ( self , other ): return isinstance ( other , MySpec ) and getattr ( self , 'my_str' ) == getattr ( other , 'my_str' ) def __setattr__ ( self , attr , value ): if attr == 'my_str' and not isinstance ( my_str , str ): raise TypeError ( \"`MySpec.my_str` should be a string.\" ) super () . __setattr__ ( attr , value ) def update ( self , my_str = MISSING ): obj = copy . deepcopy ( self ) obj . my_str = my_str return obj def transform ( self , transform = MISSING , * , my_str_transform = MISSING ): obj = copy . deepcopy ( obj ) obj = transform ( self ) obj . my_str = my_str_transform ( obj . my_str ) return obj def with_my_str ( self , value ): obj = copy . deepcopy ( self ) obj . my_str = value return obj def transform_my_str ( self , transform ): obj = copy . deepcopy ( self ) obj . my_str = transform ( self . my_str ) return obj def reset_my_str ( self ): obj = copy . deepcopy ( self ) del obj . my_str return obj The remainder of this documentation is dedicated to exploring exactly which attributes get managed by spec-classes, which methods get generated when, and how it all fits together. Managed attributes \u00b6 By default, all annotated attributes in the class decorated with @spec_class are managed by spec-classes. This means that the constructor and representation of the spec class will consider all annotated attributes, and nothing else. For example: @spec_class class MySpec : my_str : str = \"Hello\" my_int = 1 MySpec ( my_str = \"Hi\" ) # All good. MySpec ( my_int = 2 ) # Raises a TypeError (`my_int` is not annotated, and therefore not managed) You can override, if necessary, the attributes that are considered by spec-classes using the keyword arguments to the @spec_class decorator: attrs : An iterable of strings indicating the names of attributes to be included. If not already annotated on the class, these will be given an annotation of typing.Any . attrs_typed : A mapping from the string name of the attribute to the type of the attribute to use (can override class annotations). attrs_skip : An iterable of attributes names to skip during determination of which fields to manage. Note that unless attrs_skip is provided, if attrs and/or attrs_typed are provided, then spec-classes will not automatically manage other annotated attributes on the class. Extending our above example, you could do: @spec_class ( attrs_typed = { 'my_int' : int }, attrs_skip = []) class MySpec : my_str : str = \"Hello\" my_int = 1 MySpec ( my_str = \"Hi\" ) # All good. MySpec ( my_int = 2 ) # All good. Constructor \u00b6 Using the @spec_class decorator will by default add a constructor to the class (unless one is already defined on the class). You can disable the addition of a constructor by passing init=False to the decorator. All arguments to the generated constructor must be passed by name (except for the key attribute; see below ). Also, instances of spec-classes are permitted to have missing values. If the class does not provide a default value for an attribute, instances will not have the attribute present, and representations of the class will render it as MISSING . For example: @spec_class class MySpec : my_str : str MySpec () # MySpec(my_str=MISSING) MySpec () . my_str # AttributeError: `MySpec.my_str` has not yet been assigned a value. Tip It is always safe to use mutable default values when using the default constructor with your managed attributes. They will be deep-copied in the constructor before being assigned to instances of your class. For example: @spec_class class MySpec : my_list : [ 'a' ] assert MySpec () . my_list is not MySpec . my_list Keyed Spec Classes \u00b6 Most attributes on a spec-class are treated identically and without privilege. The one exception to that is an optional key attribute. Semantically, a key is intended to uniquely identify an instance of a spec-class within some context, and if configured must be assigned a value at instantiation time. To indicate that a spec-class should be \"keyed\", pass the key argument to the spec_class constructor. For example: @spec_class ( key = 'key' ) class KeyedSpec : key : str value : str KeyedSpec ( 'my_key' ) # KeyedSpec(key='my_key', value=MISSING) KeyedSpec () # TypeError: __init__() missing 1 required positional argument: 'key' Note The key attribute is the only attribute that does not need to be passed in by name to the constructor. Also: if the class has a default for the key attribute, it will be lifted up as the value in the instance (just like other attributes). Type checking \u00b6 All attributes managed by spec-classes are type-checked during initialization and any mutation. Attempts to set attributes to an invalid type will result in a TypeError . For example, from the above MySpec : MySpec ( my_str = 1 ) # TypeError: Attempt to set `MySpec.my_str` with an invalid type [got `1`; expecting `str`]. Helper methods \u00b6 To simplify the adoption of copy-on-write workflows, and to make mutation of instances more convenient and chainable, spec_class generates helper methods for the base class and every managed attribute. The number and types of methods added depends on type annotations, but in every case mutations performed by these methods are (by default) done on copies of the original instance, and so can be used safely on instances that are shared between multiple objects. Refer to the Helper Methods documentation for more details.","title":"Basic Usage"},{"location":"usage/basic/#the-spec_class-decorator","text":"The primary entry-point into spec_classes is the spec_class decorator, which takes your standard class and converts it into a \"spec-class\" (\ud83c\udf1f ooh... shiny! \ud83c\udf1f). In practice, this just means that it adds some dunder magic methods like __init__ and __setattr__ , along with a few helper methods ... and nothing else. This is intentionally very similar to the standard library's dataclass , and indeed you can largely consider spec-classes to be a generalization of it. Using spec-classes is as simple as decorating your annotated class with spec_class . For example: from spec_classes import spec_class @spec_class class MySpec : my_str : str The result is a class that: Thoroughly type-checks class attributes whenever and however they are mutated. Has helper methods that assist with the mutation of annotated attributes, allowing one to adopt copy-on-write workflows (see below for more details). Knows how to output a human-friendly representation of the spec class when printed. Knows how to compare itself with other instances of the spec class. As such, and with a huge amount of simplification, the above spec-class declaration would be roughly similar to writing something like: import copy from spec_classes import MISSING class MySpec : def __init__ ( self , my_str = MISSING ) if my_str is not MISSING : self . my_str = my_str def __repr__ ( self ): return f \"MySpec(my_str= { getattr ( self , 'my_str' , MISSING ) } \" ) def __eq__ ( self , other ): return isinstance ( other , MySpec ) and getattr ( self , 'my_str' ) == getattr ( other , 'my_str' ) def __setattr__ ( self , attr , value ): if attr == 'my_str' and not isinstance ( my_str , str ): raise TypeError ( \"`MySpec.my_str` should be a string.\" ) super () . __setattr__ ( attr , value ) def update ( self , my_str = MISSING ): obj = copy . deepcopy ( self ) obj . my_str = my_str return obj def transform ( self , transform = MISSING , * , my_str_transform = MISSING ): obj = copy . deepcopy ( obj ) obj = transform ( self ) obj . my_str = my_str_transform ( obj . my_str ) return obj def with_my_str ( self , value ): obj = copy . deepcopy ( self ) obj . my_str = value return obj def transform_my_str ( self , transform ): obj = copy . deepcopy ( self ) obj . my_str = transform ( self . my_str ) return obj def reset_my_str ( self ): obj = copy . deepcopy ( self ) del obj . my_str return obj The remainder of this documentation is dedicated to exploring exactly which attributes get managed by spec-classes, which methods get generated when, and how it all fits together.","title":"The spec_class decorator"},{"location":"usage/basic/#managed-attributes","text":"By default, all annotated attributes in the class decorated with @spec_class are managed by spec-classes. This means that the constructor and representation of the spec class will consider all annotated attributes, and nothing else. For example: @spec_class class MySpec : my_str : str = \"Hello\" my_int = 1 MySpec ( my_str = \"Hi\" ) # All good. MySpec ( my_int = 2 ) # Raises a TypeError (`my_int` is not annotated, and therefore not managed) You can override, if necessary, the attributes that are considered by spec-classes using the keyword arguments to the @spec_class decorator: attrs : An iterable of strings indicating the names of attributes to be included. If not already annotated on the class, these will be given an annotation of typing.Any . attrs_typed : A mapping from the string name of the attribute to the type of the attribute to use (can override class annotations). attrs_skip : An iterable of attributes names to skip during determination of which fields to manage. Note that unless attrs_skip is provided, if attrs and/or attrs_typed are provided, then spec-classes will not automatically manage other annotated attributes on the class. Extending our above example, you could do: @spec_class ( attrs_typed = { 'my_int' : int }, attrs_skip = []) class MySpec : my_str : str = \"Hello\" my_int = 1 MySpec ( my_str = \"Hi\" ) # All good. MySpec ( my_int = 2 ) # All good.","title":"Managed attributes"},{"location":"usage/basic/#constructor","text":"Using the @spec_class decorator will by default add a constructor to the class (unless one is already defined on the class). You can disable the addition of a constructor by passing init=False to the decorator. All arguments to the generated constructor must be passed by name (except for the key attribute; see below ). Also, instances of spec-classes are permitted to have missing values. If the class does not provide a default value for an attribute, instances will not have the attribute present, and representations of the class will render it as MISSING . For example: @spec_class class MySpec : my_str : str MySpec () # MySpec(my_str=MISSING) MySpec () . my_str # AttributeError: `MySpec.my_str` has not yet been assigned a value. Tip It is always safe to use mutable default values when using the default constructor with your managed attributes. They will be deep-copied in the constructor before being assigned to instances of your class. For example: @spec_class class MySpec : my_list : [ 'a' ] assert MySpec () . my_list is not MySpec . my_list","title":"Constructor"},{"location":"usage/basic/#keyed-spec-classes","text":"Most attributes on a spec-class are treated identically and without privilege. The one exception to that is an optional key attribute. Semantically, a key is intended to uniquely identify an instance of a spec-class within some context, and if configured must be assigned a value at instantiation time. To indicate that a spec-class should be \"keyed\", pass the key argument to the spec_class constructor. For example: @spec_class ( key = 'key' ) class KeyedSpec : key : str value : str KeyedSpec ( 'my_key' ) # KeyedSpec(key='my_key', value=MISSING) KeyedSpec () # TypeError: __init__() missing 1 required positional argument: 'key' Note The key attribute is the only attribute that does not need to be passed in by name to the constructor. Also: if the class has a default for the key attribute, it will be lifted up as the value in the instance (just like other attributes).","title":"Keyed Spec Classes"},{"location":"usage/basic/#type-checking","text":"All attributes managed by spec-classes are type-checked during initialization and any mutation. Attempts to set attributes to an invalid type will result in a TypeError . For example, from the above MySpec : MySpec ( my_str = 1 ) # TypeError: Attempt to set `MySpec.my_str` with an invalid type [got `1`; expecting `str`].","title":"Type checking"},{"location":"usage/basic/#helper-methods","text":"To simplify the adoption of copy-on-write workflows, and to make mutation of instances more convenient and chainable, spec_class generates helper methods for the base class and every managed attribute. The number and types of methods added depends on type annotations, but in every case mutations performed by these methods are (by default) done on copies of the original instance, and so can be used safely on instances that are shared between multiple objects. Refer to the Helper Methods documentation for more details.","title":"Helper methods"},{"location":"usage/special_types/","text":"Spec classes do not require you to use any special types: you can use standard types from the standard library or any custom type you choose. However, the spec_classes library does come with some useful types that you can use to enrich your spec classes (or indeed any class). These are detailed below, and are all available by importing from spec_classes.types . Attribute specification \u00b6 In most cases, you can simply set spec-class attribute defaults (and or lack thereof) directly in the class definition. This attribute will then be \"managed\", and included in the constructor, equality comparisons, representations, etc. However, in some cases you need to customize this behavior... and that's where field and Attr come in. field \u00b6 Spec-classes is compatible with the standard-libraries dataclass field specification , so you can use that directly as the attribute values in spec-classes just as you would in a dataclass. However, in most cases you will want to use Attr below. Attr \u00b6 Attr is to spec_class what field is to dataclass , and it offers a superset of the API of field , making it a drop in replacement. The signature of Attr is: Attr ( * , default : Any = MISSING , default_factory : Callable [[], Any ] = MISSING , init : bool = True , repr : bool = True , compare : bool = True , hash : Optional [ bool ] = None , metadata : Optional [ Any ] = None , desc : Optional [ str ] = None , do_not_copy : bool = False , invalidated_by : Optional [ Iterable [ str ]] = None , ) The default value for the attribute is set by either default or default_factory , and init , repr , compare and hash control whether the attribute is considered by __init__ , __repr__ , __eq__ and __hash__ respectively. Metadata is an arbitrary object that is not looked at by spec-classes. desc is a docstring for the attribute. do_not_copy is an instruction to spec-classes not to copy the attribute, and so when the parent spec-class is copied the new spec-class instance will have a reference to the same attribute. invalidated_by is an instruction to spec-classes to reset this attribute whenever the attributes in this list are mutated. Note Hashing is not yet implemented by spec-classes, but is provided here for API compatibility. Ordering of spec-classes is also not yet implemented. For more information, refer to help(Attr) . Validated Types \u00b6 Spec-classes type-checks all attributes by default. Sometimes, however, simple type-checks are insufficient to guarantee a valid value. For example, the age field might require a non-negative integer, and so type-checking against int would not be sufficient. To help with these cases, spec_classes offers several validation types (all of which are implemented in spec_classes.types.validated ). These are detailed below. ValidatedType \u00b6 This is the base class that powers all validated type checking offered by spec_classes . It translates isinstance(obj, ValidatedType) into ValidatedType.validate(obj) , allowing for arbitrary validation logic. To leverage this you can either subclass this class, or use the validated wrapper below. An example subclass of ValidatedType might look something like: from abc import classmethod from spec_classes.types import ValidatedType class PositiveInt ( ValidatedType ): @classmethod def validate ( self , obj ): return isinstance ( obj , int ) and obj > 0 This object could then be used just like any other type annotation: @spec_class class MySpec : value : PositiveInt validated \u00b6 validated is a wrapper around ValidatedType that bypasses the need to manually subclass. Instead, you can just call this function to generate a type and use it inline or via variable. This signature of this function is: def validated ( validator : Callable [[ Any ], bool ], name : str = \"validated\" ): ... An example use-case is: @spec_class class MySpec : proper_noun : validated ( lambda x : x [ 0 ] == x [ 0 ] . upper (), name = 'ProperNoun' ) MySpec ( proper_noun = \"hi\" ) # TypeError: Attempt to set `MySpec.proper_noun` with an invalid type [got `'hi'`; expecting `ProperNoun`]. bounded \u00b6 bounded is a pre-rolled special case of validated which allows you to put upper and lower bounds on numerical types. The signature of bounded is: def bounded ( numeric_type : Type , * , ge : numbers . Number = None , gt : numbers . Number = None , le : numbers . Number = None , lt : numbers . Number = None , ): ... and you can refer to help(bounded) for more details. An example use-case might be: @spec_class class Person : age : bounded ( int , ge = 0 ) Person ( age =- 1 ) # TypeError: Attempt to set `Person.age` with an invalid type [got `-1`; expecting `int\u220a[0,\u221e)`]. Keyed Containers \u00b6 Spec classes are able to optionally set a key attribute that is intended to uniquely identify instances within some context. It is useful to be able to use these keys to lookup items when they are stored in collections without having to iterate over all items in the collection to find them. For this purpose, spec_classes offers two special collection types (implemented in spec_classes.types.keyed ): KeyedList and KeyedSet that act respectively like standard lists and sets, but also allow looking up and mutating elements by key. These are described in more detail below. Key lookups \u00b6 The Keyed* containers in spec_classes both subclass from KeyedBase , which implements the default key lookup strategy (among several other things). The default key lookup strategy is: Check to see if item type is a spec-class, and if so if it has a key attribute. If so, that is the key. Attempt to hash the object. If the item is hashable, the object itself is the key. This can be overridden as detailed below. KeyedList \u00b6 KeyedList is a generic container that behave exactly like a list, but also layers on the ability to look up items by key. The computational complexity for list-like operations is the same as the base list class, with additional dict-like operations with complexity as follows: O(1) lookups by key O(n) replacement by key O(n) deletes by key Under the hood these functionalities are achieved by storing both a list and a dict representation of the items stored in the container, and adding dict-like methods .keys() , .items() , .get() and a special .index_for_key() method that finds the list index for a nominated key. The constructor to KeyedList takes two optional arguments: sequence which takes a sequence of values to pre-fill the list, and key a method that takes an item and returns a key (used to override the default key lookup algorithm). You can also explicitly indicate the types that the container will store using regular python typing notation; that is: KeyedList[<item type>, <key type>] . When an object with the same key already exists in side a KeyedList a ValueError is raised. Examples: l = KeyedList ([ 'a' , 'b' , 'c' ]) l [ 0 ] # 'a' l [ 'a' ] # 'a' ('a' is hashable, and so is its own key) set ( l . keys ()) # {'a', 'b', 'c'} l . append ( 'a' ) # ValueError: Item with key `'a'` already in `KeyedList`. @spec_class ( key = 'key' ) class KeyedSpec : key : str l = KeyedList [ KeyedSpec , str ]() l . append ( KeyedSpec ( 'object_1' )) str ( l ) # KeyedList[KeyedSpec, str]([KeyedSpec(key='object_1')]) l [ 0 ] # KeyedSpec(key='object_1') l [ 'object_1' ] # KeyedSpec(key='object_1') KeyedSet \u00b6 KeyedSet behaves almost identically to KeyedList except that order is not preserved, and key collisions are by default acceptable (resulting in existing objects with the same key being overridden). It behaves exactly like a set in that the keys (which are supposed to uniquely identify the objects) are stored by hash, and mapped to the values of the set. Internally this is just using a dictionary for storage. Warning Care should be taken when using KeyedSet where the key of the item is of the same type as the item itself. In such cases there is the risk of ambiguity about whether an item being referenced in the collection is being referenced by key or by value. For example, when .discard(<item>) is called, KeyedSet allows item or keys to be passed. Note that if an item is identical to its key there is no ambiguity. The computational complexity for set-like operations is the same as the base set class, with additional dict-like operations with complexity as follows: O(1) lookups by key O(1) deletes by key If it is important to you that attempts to override objects with the same key fail unless the objects are equivalent, you can set enforce_item_equivalence to True in the constructor. Examples: l = KeyedSet ([ 'a' , 'b' , 'c' ]) 'a' in l l [ 'a' ] # 'a' ('a' is hashable, and so is its own key) set ( l . keys ()) # {'a', 'b', 'c'} l . add ( 'a' ) # This is fine. @spec_class ( key = 'key' ) class KeyedSpec : key : str value : int = 0 l = KeyedSet [ KeyedSpec , str ]( enforce_item_equivalence = True ) l . add ( KeyedSpec ( 'object_1' )) str ( l ) # KeyedSet[KeyedSpec, str]([KeyedSpec(key='object_1')]) l [ 'object_1' ] # KeyedSpec(key='object_1') l . add ( KeyedSpec ( 'object_1' , value = 10 )) # ValueError: Item for `'object_1'` already exists, and is not equal to the incoming item. Descriptors \u00b6 The standard Python library offers various implementations of the descriptor protocol , which allows you to modify the way in which attributes are looked up on object instances. One of the most common of these is property . You can continue to use property with spec-classes, but the down-side of property is that it (unless you also manually supply a setter ) makes the attribute read-only. Since spec-classes are often used to store configuration it is often useful to be able treat property s as \"default\" values, and still override them by default. For this reason we provide spec_property , detailed below, which behaves like a property but has a setter by default, as well as providing support for caching. We also provide AttrProxy which is for even more esoteric cases where you want two attributes to be linked not only for read operations, but also write operations. Both are detailed below, and can be used inside of spec-classes or non-spec-classes alike. spec_property \u00b6 spec_property is implemented in spec_classes.types.spec_property , and behaves exactly like property except that it provides a setter by default allowing it be overwritten (and reset using deletion), and provides caching. You can use spec_property as follows: class MyClass : @spec_property def value ( self ): return 1 m = MyClass () m . value # 1 m . value = 10 m . value # 10 The behavior of spec_property can also be customized as follows (with defaults as shown): class MyClass : @spec_property ( overridable = True , # Whether to allow overriding by default. warn_on_override = False , # Whether to warn the user when the property getter # is overridden. Can be a boolean, string, or `Warning` instance. # If non-boolean, then it is treated as the message to present to # the user using `warnings.warn`. cache = False , # Whether to cache the result after first evaluation. invalidated_by = None , # An iterable of attributes which when mutated # invalidate the cache (only supported when used with spec-classes) allow_attribute_error = True , # Whether to allow properties to raise # `AttributeErrors` which are often masked during attribute lookup. ) def method ( self ): ... # And of course you can override the setters as you would with regular properties @method . setter def method ( self , value ): ... As always you can refer to the inline help(spec_property) for more details. classproperty \u00b6 classproperty is implemented in spec_classes.types.classproperty , and behaves exactly like spec_property except that it acts on classmethods, and does not offer inbuilt access to spec-class state. You can use classproperty as follows: class MyClass : @classproperty ( overridable = False , # Whether to allow overriding by default. warn_on_override = False , # Whether to warn the user when the property getter # is overridden. Can be a boolean, string, or `Warning` instance. # If non-boolean, then it is treated as the message to present to # the user using `warnings.warn`. cache = False , # Whether to cache the result after first evaluation. cache_per_subclass = False , # Whether cache should be stored per subclass # rather than once for all classes. allow_attribute_error = True , # Whether to allow properties to raise # `AttributeErrors` which are often masked during attribute lookup. ) def method ( cls ): ... # And of course you can override the setters as you would with regular properties @method . setter def method ( cls , value ): ... AttrProxy \u00b6 AttrProxy is implemented in spec_classes.types.attr_proxy , and allows one attribute to proxy another attribute. This is especially useful if you have changed the name of an attribute and need to provide backwards compatibility for an indefinite period; or if one attribute is supposed to mirror another attribute unless overwritten (e.g. the label of a class might be the \"key\" unless overwritten). This functionality could obviously be implemented directly using property , which may be advisable if readability is more important than concision. You can construct an AttrProxy instance using: AttrProxy ( attr = \"<attribute to proxy on same instance>\" , # Required! transform = lambda x : x ** 2 , # Optional transform on attribute value. passthrough = False , # Defaults to `False`, whether to pass on mutations back through to the proxied attribute fallback = MISSING , # Defaults to `MISSING`; the value to return if the proxied attribute is not set. ) Example: @spec_class ( key = \"key\" ) class MyObject : key : str label : str = AttrProxy ( \"key\" , transform = lambda key : key . replace ( '_' , ' ' ) . title ()) m = MyObject ( \"object_1\" ) m . label # 'Object 1' m . label = \"My Object\" m . label # 'My Object' Sentinels \u00b6 It is often useful to have at least one value reserved for use as a sentinel. Depending on the context they can be interpreted as an failure state or trigger some fallback behavior. In spec_classes , we use MISSING . MISSING \u00b6 In spec_classes , spec_classes.MISSING is the sentinel used to indicate that an attribute or argument value has not (yet) been provided. If you are using spec-classes in your project, you can feel free to use this sentinel also. MISSING is implemented in spec_classes.types.missing , and is an instance of the singleton class _MissingType (every instantiation will return the same instance). MISSING is falsey ( bool(MISSING) is False ), but otherwise cannot be compared to anything else. Its string representation is 'MISSING' .","title":"Special Types"},{"location":"usage/special_types/#attribute-specification","text":"In most cases, you can simply set spec-class attribute defaults (and or lack thereof) directly in the class definition. This attribute will then be \"managed\", and included in the constructor, equality comparisons, representations, etc. However, in some cases you need to customize this behavior... and that's where field and Attr come in.","title":"Attribute specification"},{"location":"usage/special_types/#field","text":"Spec-classes is compatible with the standard-libraries dataclass field specification , so you can use that directly as the attribute values in spec-classes just as you would in a dataclass. However, in most cases you will want to use Attr below.","title":"field"},{"location":"usage/special_types/#attr","text":"Attr is to spec_class what field is to dataclass , and it offers a superset of the API of field , making it a drop in replacement. The signature of Attr is: Attr ( * , default : Any = MISSING , default_factory : Callable [[], Any ] = MISSING , init : bool = True , repr : bool = True , compare : bool = True , hash : Optional [ bool ] = None , metadata : Optional [ Any ] = None , desc : Optional [ str ] = None , do_not_copy : bool = False , invalidated_by : Optional [ Iterable [ str ]] = None , ) The default value for the attribute is set by either default or default_factory , and init , repr , compare and hash control whether the attribute is considered by __init__ , __repr__ , __eq__ and __hash__ respectively. Metadata is an arbitrary object that is not looked at by spec-classes. desc is a docstring for the attribute. do_not_copy is an instruction to spec-classes not to copy the attribute, and so when the parent spec-class is copied the new spec-class instance will have a reference to the same attribute. invalidated_by is an instruction to spec-classes to reset this attribute whenever the attributes in this list are mutated. Note Hashing is not yet implemented by spec-classes, but is provided here for API compatibility. Ordering of spec-classes is also not yet implemented. For more information, refer to help(Attr) .","title":"Attr"},{"location":"usage/special_types/#validated-types","text":"Spec-classes type-checks all attributes by default. Sometimes, however, simple type-checks are insufficient to guarantee a valid value. For example, the age field might require a non-negative integer, and so type-checking against int would not be sufficient. To help with these cases, spec_classes offers several validation types (all of which are implemented in spec_classes.types.validated ). These are detailed below.","title":"Validated Types"},{"location":"usage/special_types/#validatedtype","text":"This is the base class that powers all validated type checking offered by spec_classes . It translates isinstance(obj, ValidatedType) into ValidatedType.validate(obj) , allowing for arbitrary validation logic. To leverage this you can either subclass this class, or use the validated wrapper below. An example subclass of ValidatedType might look something like: from abc import classmethod from spec_classes.types import ValidatedType class PositiveInt ( ValidatedType ): @classmethod def validate ( self , obj ): return isinstance ( obj , int ) and obj > 0 This object could then be used just like any other type annotation: @spec_class class MySpec : value : PositiveInt","title":"ValidatedType"},{"location":"usage/special_types/#validated","text":"validated is a wrapper around ValidatedType that bypasses the need to manually subclass. Instead, you can just call this function to generate a type and use it inline or via variable. This signature of this function is: def validated ( validator : Callable [[ Any ], bool ], name : str = \"validated\" ): ... An example use-case is: @spec_class class MySpec : proper_noun : validated ( lambda x : x [ 0 ] == x [ 0 ] . upper (), name = 'ProperNoun' ) MySpec ( proper_noun = \"hi\" ) # TypeError: Attempt to set `MySpec.proper_noun` with an invalid type [got `'hi'`; expecting `ProperNoun`].","title":"validated"},{"location":"usage/special_types/#bounded","text":"bounded is a pre-rolled special case of validated which allows you to put upper and lower bounds on numerical types. The signature of bounded is: def bounded ( numeric_type : Type , * , ge : numbers . Number = None , gt : numbers . Number = None , le : numbers . Number = None , lt : numbers . Number = None , ): ... and you can refer to help(bounded) for more details. An example use-case might be: @spec_class class Person : age : bounded ( int , ge = 0 ) Person ( age =- 1 ) # TypeError: Attempt to set `Person.age` with an invalid type [got `-1`; expecting `int\u220a[0,\u221e)`].","title":"bounded"},{"location":"usage/special_types/#keyed-containers","text":"Spec classes are able to optionally set a key attribute that is intended to uniquely identify instances within some context. It is useful to be able to use these keys to lookup items when they are stored in collections without having to iterate over all items in the collection to find them. For this purpose, spec_classes offers two special collection types (implemented in spec_classes.types.keyed ): KeyedList and KeyedSet that act respectively like standard lists and sets, but also allow looking up and mutating elements by key. These are described in more detail below.","title":"Keyed Containers"},{"location":"usage/special_types/#key-lookups","text":"The Keyed* containers in spec_classes both subclass from KeyedBase , which implements the default key lookup strategy (among several other things). The default key lookup strategy is: Check to see if item type is a spec-class, and if so if it has a key attribute. If so, that is the key. Attempt to hash the object. If the item is hashable, the object itself is the key. This can be overridden as detailed below.","title":"Key lookups"},{"location":"usage/special_types/#keyedlist","text":"KeyedList is a generic container that behave exactly like a list, but also layers on the ability to look up items by key. The computational complexity for list-like operations is the same as the base list class, with additional dict-like operations with complexity as follows: O(1) lookups by key O(n) replacement by key O(n) deletes by key Under the hood these functionalities are achieved by storing both a list and a dict representation of the items stored in the container, and adding dict-like methods .keys() , .items() , .get() and a special .index_for_key() method that finds the list index for a nominated key. The constructor to KeyedList takes two optional arguments: sequence which takes a sequence of values to pre-fill the list, and key a method that takes an item and returns a key (used to override the default key lookup algorithm). You can also explicitly indicate the types that the container will store using regular python typing notation; that is: KeyedList[<item type>, <key type>] . When an object with the same key already exists in side a KeyedList a ValueError is raised. Examples: l = KeyedList ([ 'a' , 'b' , 'c' ]) l [ 0 ] # 'a' l [ 'a' ] # 'a' ('a' is hashable, and so is its own key) set ( l . keys ()) # {'a', 'b', 'c'} l . append ( 'a' ) # ValueError: Item with key `'a'` already in `KeyedList`. @spec_class ( key = 'key' ) class KeyedSpec : key : str l = KeyedList [ KeyedSpec , str ]() l . append ( KeyedSpec ( 'object_1' )) str ( l ) # KeyedList[KeyedSpec, str]([KeyedSpec(key='object_1')]) l [ 0 ] # KeyedSpec(key='object_1') l [ 'object_1' ] # KeyedSpec(key='object_1')","title":"KeyedList"},{"location":"usage/special_types/#keyedset","text":"KeyedSet behaves almost identically to KeyedList except that order is not preserved, and key collisions are by default acceptable (resulting in existing objects with the same key being overridden). It behaves exactly like a set in that the keys (which are supposed to uniquely identify the objects) are stored by hash, and mapped to the values of the set. Internally this is just using a dictionary for storage. Warning Care should be taken when using KeyedSet where the key of the item is of the same type as the item itself. In such cases there is the risk of ambiguity about whether an item being referenced in the collection is being referenced by key or by value. For example, when .discard(<item>) is called, KeyedSet allows item or keys to be passed. Note that if an item is identical to its key there is no ambiguity. The computational complexity for set-like operations is the same as the base set class, with additional dict-like operations with complexity as follows: O(1) lookups by key O(1) deletes by key If it is important to you that attempts to override objects with the same key fail unless the objects are equivalent, you can set enforce_item_equivalence to True in the constructor. Examples: l = KeyedSet ([ 'a' , 'b' , 'c' ]) 'a' in l l [ 'a' ] # 'a' ('a' is hashable, and so is its own key) set ( l . keys ()) # {'a', 'b', 'c'} l . add ( 'a' ) # This is fine. @spec_class ( key = 'key' ) class KeyedSpec : key : str value : int = 0 l = KeyedSet [ KeyedSpec , str ]( enforce_item_equivalence = True ) l . add ( KeyedSpec ( 'object_1' )) str ( l ) # KeyedSet[KeyedSpec, str]([KeyedSpec(key='object_1')]) l [ 'object_1' ] # KeyedSpec(key='object_1') l . add ( KeyedSpec ( 'object_1' , value = 10 )) # ValueError: Item for `'object_1'` already exists, and is not equal to the incoming item.","title":"KeyedSet"},{"location":"usage/special_types/#descriptors","text":"The standard Python library offers various implementations of the descriptor protocol , which allows you to modify the way in which attributes are looked up on object instances. One of the most common of these is property . You can continue to use property with spec-classes, but the down-side of property is that it (unless you also manually supply a setter ) makes the attribute read-only. Since spec-classes are often used to store configuration it is often useful to be able treat property s as \"default\" values, and still override them by default. For this reason we provide spec_property , detailed below, which behaves like a property but has a setter by default, as well as providing support for caching. We also provide AttrProxy which is for even more esoteric cases where you want two attributes to be linked not only for read operations, but also write operations. Both are detailed below, and can be used inside of spec-classes or non-spec-classes alike.","title":"Descriptors"},{"location":"usage/special_types/#spec_property","text":"spec_property is implemented in spec_classes.types.spec_property , and behaves exactly like property except that it provides a setter by default allowing it be overwritten (and reset using deletion), and provides caching. You can use spec_property as follows: class MyClass : @spec_property def value ( self ): return 1 m = MyClass () m . value # 1 m . value = 10 m . value # 10 The behavior of spec_property can also be customized as follows (with defaults as shown): class MyClass : @spec_property ( overridable = True , # Whether to allow overriding by default. warn_on_override = False , # Whether to warn the user when the property getter # is overridden. Can be a boolean, string, or `Warning` instance. # If non-boolean, then it is treated as the message to present to # the user using `warnings.warn`. cache = False , # Whether to cache the result after first evaluation. invalidated_by = None , # An iterable of attributes which when mutated # invalidate the cache (only supported when used with spec-classes) allow_attribute_error = True , # Whether to allow properties to raise # `AttributeErrors` which are often masked during attribute lookup. ) def method ( self ): ... # And of course you can override the setters as you would with regular properties @method . setter def method ( self , value ): ... As always you can refer to the inline help(spec_property) for more details.","title":"spec_property"},{"location":"usage/special_types/#classproperty","text":"classproperty is implemented in spec_classes.types.classproperty , and behaves exactly like spec_property except that it acts on classmethods, and does not offer inbuilt access to spec-class state. You can use classproperty as follows: class MyClass : @classproperty ( overridable = False , # Whether to allow overriding by default. warn_on_override = False , # Whether to warn the user when the property getter # is overridden. Can be a boolean, string, or `Warning` instance. # If non-boolean, then it is treated as the message to present to # the user using `warnings.warn`. cache = False , # Whether to cache the result after first evaluation. cache_per_subclass = False , # Whether cache should be stored per subclass # rather than once for all classes. allow_attribute_error = True , # Whether to allow properties to raise # `AttributeErrors` which are often masked during attribute lookup. ) def method ( cls ): ... # And of course you can override the setters as you would with regular properties @method . setter def method ( cls , value ): ...","title":"classproperty"},{"location":"usage/special_types/#attrproxy","text":"AttrProxy is implemented in spec_classes.types.attr_proxy , and allows one attribute to proxy another attribute. This is especially useful if you have changed the name of an attribute and need to provide backwards compatibility for an indefinite period; or if one attribute is supposed to mirror another attribute unless overwritten (e.g. the label of a class might be the \"key\" unless overwritten). This functionality could obviously be implemented directly using property , which may be advisable if readability is more important than concision. You can construct an AttrProxy instance using: AttrProxy ( attr = \"<attribute to proxy on same instance>\" , # Required! transform = lambda x : x ** 2 , # Optional transform on attribute value. passthrough = False , # Defaults to `False`, whether to pass on mutations back through to the proxied attribute fallback = MISSING , # Defaults to `MISSING`; the value to return if the proxied attribute is not set. ) Example: @spec_class ( key = \"key\" ) class MyObject : key : str label : str = AttrProxy ( \"key\" , transform = lambda key : key . replace ( '_' , ' ' ) . title ()) m = MyObject ( \"object_1\" ) m . label # 'Object 1' m . label = \"My Object\" m . label # 'My Object'","title":"AttrProxy"},{"location":"usage/special_types/#sentinels","text":"It is often useful to have at least one value reserved for use as a sentinel. Depending on the context they can be interpreted as an failure state or trigger some fallback behavior. In spec_classes , we use MISSING .","title":"Sentinels"},{"location":"usage/special_types/#missing","text":"In spec_classes , spec_classes.MISSING is the sentinel used to indicate that an attribute or argument value has not (yet) been provided. If you are using spec-classes in your project, you can feel free to use this sentinel also. MISSING is implemented in spec_classes.types.missing , and is an instance of the singleton class _MissingType (every instantiation will return the same instance). MISSING is falsey ( bool(MISSING) is False ), but otherwise cannot be compared to anything else. Its string representation is 'MISSING' .","title":"MISSING"},{"location":"usage/methods/","text":"To simplify the process of building and mutating spec-class instances, spec_class generates helper methods and attaches them to class. The number and types of methods added depends on type annotations, but in every case mutations performed by these methods are (by default) done on copies of the original instance, and so can be used safely on instances that are shared between multiple objects. A note on naming Generated methods are named consistently according to their action on the spec-class. In particular: with always means that a new value is being associated with the spec-class, replacing (scalar methods) or appending to (collection methods) existing values. update always means that an existing object is being mutated, and that attributes not referenced are maintained as is. transform always means that a function is going to be applied to an existing value, and that (like update ) and attributes not referenced will be maintained as is. reset always means that the attributes referenced will be reset to their default values. The base class has three \"toplevel\" methods added: update transform reset which can be used to mutate the state of the spec-class as a whole. All managed attributes have four \"scalar\" methods added: with_<attr> update_<attr> transform_<attr> reset_<attr> These methods allow the replacement or mutation of attribute values, and are called scalar because each attribute is treated as one entity by these methods (as compared to methods that mutate elements of a collection, as below). Attributes which have collection types (subclasses of MutableSequence , MutableMapping or MutableSet ) also have attract four more \"collection\" methods: with_<attr_singular> update_<attr_singular> transform_<attr_singular> without_<attr_singular> These methods act on individual elements within these collections. By way of demonstration, here is a simple example of how these methods can be used together: @spec_class class ClassExaminationResults : teacher_name : str student_grades : Dict [ str , float ] ( ClassExaminationResults () . update ( teacher_name = 'TBD' ) . with_teacher_name ( 'Mr. Didactic' ) . with_student_grade ( 'Jerry' , 12.3 ) . with_student_grade ( 'Jane' , 14.1 ) . without_student_grade ( 'Jerry' ) . transform_teacher_name ( lambda name : f ' { name } and Mrs. Elocution' ) ) # ClassExaminationResults( # teacher_name='Mr. Didactic and Mrs. Elocution', # student_grades={ # 'Jane': 14.1 # } # ) For more information about how these methods work, please peruse the Toplevel Methods , Scalar Methods and Collection Methods documentation.","title":"Overview"},{"location":"usage/methods/collections/","text":"Attributes that have a type subclassing from MutableSequence , MutableMapping or MutableSet (see collections.abc in the standard library; and note that these include the standard list , dict and set datatypes) are considered to be collections. In addition to the scalar helper methods, spec-classes also adds three more helper methods to assist with the mutation of elements of the collection; again with a view to simplifying incremental setting of the attributes and/or adoption of a copy-on-write workflow. The helper methods are: with_<attr_singular>(...) update_<attr_singular>(...) transform_<attr_singular>(...) without_<attr_sigular>(...) The concrete signatures differ based on the collection type, and so will be explored in more detail below. As for the scalar methods, when the collected item type is a spec-class, additional fields are added to the methods to allow direct access or mutation of attributes of the elements in the collection. Method \"Singular\" Naming \u00b6 As indicated above, the collection methods are named after the singular form of the attribute name. The generation of the singular form is handled by the excellent inflect library. This approach has two main benefits: 1. It clearly distinguishes the target of the collection from the scalar helper methods. 2. It encourages sensible naming of collections (i.e. plural names). If inflect cannot find a singular form either because the attribute name was not plural, or the plural form is the same as the singular form, or the plural form overlaps with an existing attribute, then a suffix of _item will be used instead. If the resulting singular form overlaps with an existing attribute, a RuntimeError is raised and the user is invited to remedy the problem by renaming the attribute(s). By way of example, here are a few mappings: attribute name singular form numbers number children child errata erratum collection collection_item Mutable Sequences \u00b6 The helper method signatures for mutable sequences (including list ) are: with_<attr_singular>(_item, *, _index=MISSING, _insert=False, _inplace=False, _if=True) : Adds an element to the collection when _if is True . If _index is provided, the item at that index is replaced unless _insert is True in which case the new item is inserted before it. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_value_or_index, _new_item=MISSING, *, _by_index=MISSING, _inplace=False, _if=True) : Updates/replaces an element of the collection. Indexing semantics are as for transform_<attr_singular> below. transform_<attr_singular>(_value_or_index, _transform, *, _by_index=MISSING, _inplace=False, _if=True) : Transforms an element of the collection if _if is True . The item to be transformed is passed to the callable _transform , and is: if _by_index is False , the first instance of _value_or_index in the collection. if _by_index is True , the item at index _value_or_index . If _by_index is not specified, it defaults to True if _value_or_index is not of the same type as as that contained in the sequence. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. - without_<attr_singular>(_value_or_index, *, _by_index: bool = False, _inplace: bool = False, _if=True) : Removes an element from the collection if _if is True . The item to be removed is: if _by_index is False , the first instance of _value_or_index in the collection. if _by_index is True , the item at index _value_or_index . If _by_index is not specified, it defaults to True if _value_or_index is not of the same type as as that contained in the sequence. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class FavoriteNumbers : numbers : List [ int ] = [] assert FavoriteNumbers () . with_number ( 10 ) . without_number ( 10 ) . numbers == [] Mutable Mappings \u00b6 The helper method signatures for mutable mappings (including dict ) are: with_<attr_singular>(_key, _value, *, _inplace=False, _if=True) : Adds an element to the collection when _if is True by setting the value assigned to key _key to value _value . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_key, _new_item=MISSING, *, _inplace=False, _if=True) : Updates/replaces an element of the collection when _if is True .If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. transform_<attr_singular>(_key, _transform, *, _inplace=False, _if=True) : Transforms the value associated with key _key by passing it through the callable _transform when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. without_<attr_singular>(_key, *, _inplace: bool = False, _if=True) : Removes the mapping for _key from the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class ExaminationScores : scores : Dict [ str , float ] = {} assert ( ExaminationScores () . with_score ( \"Peter\" , 10.1 ) . with_score ( \"Justine\" , 13.3 ) . without_score ( \"Peter\" ) . scores ) == { 'Peter' : 10.1 } Mutable Sets \u00b6 The helper method signatures for mutable sets (including set ) are: with_<attr_singular>(_item, *, _inplace=False, _if=True) : Adds the nominated element _item to the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_item, _new_item=MISSING, *, _inplace=False, _if=True) : Updates/replaces an element of the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. transform_<attr_singular>(_item, _transform, *, _inplace=False, _if=True) : Transforms the nominated _item by passing it through the callable _transform when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. without_<attr_singular>(_item, *, _inplace: bool = False, _if=True) : Removes _item from the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class FavoriteNumbers : numbers : Set [ int ] assert ( FavoriteNumbers () . with_number ( 1 ) . with_number ( 2 ) . transform_number ( 1 , lambda x : x + 1 ) . without_number ( 2 ) . numbers ) == set () Extensions for spec-class types \u00b6 Just as for the scalar methods, if the item stored within any of the collections above is a spec-class, then the .with_<attr_singular>() and .transform_<attr_singular>() method signatures are extended with to allow direct mutation of the attributes of the nested spec classes. The following example is for sequence containers but the logic is the same for all collections. @spec_class class Box : label : str items : List [ str ] children : List [ \"Box\" ] help ( Box () . with_child ) # with_child(_item: __main__.Box = MISSING, *, _index: int = MISSING, _insert: bool = False, _inplace: bool = False, _if: bool = True, label: str = None, items: List[str] = None, children: List[__main__.Box] = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with an item added to or updated in `children`. # # Args: # _item: A new `Box` instance for children. # _index: Index for which to insert or replace, depending on `insert`; # if not provided, append. # _insert: Insert item before children[index], otherwise replace this # index. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # label: An optional new value for `child.label`. # items: An optional new value for `child.items`. # children: An optional new value for `child.children`. # Returns: # A reference to the mutated `Box` instance. help ( Box () . transform_child ) # transform_child(_value_or_index: Union[__main__.Box, int], _transform: Callable = MISSING, *, _by_index: bool = MISSING, _inplace: bool = False, _if: bool = True, label: str = None, items: List[str] = None, childre # n: List[__main__.Box] = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with an item transformed in `children`. # # Args: # _value_or_index: The value to transform, or (if `by_index=True`) its # index. # _transform: A function that takes the old item as input, and returns # the new item. # _by_index: If True, value_or_index is the index of the item to # transform. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # label: An optional transformer for `child.label`. # items: An optional transformer for `child.items`. # children: An optional transformer for `child.children`. # Returns: # A reference to the mutated `Box` instance.","title":"Collection Methods"},{"location":"usage/methods/collections/#method-singular-naming","text":"As indicated above, the collection methods are named after the singular form of the attribute name. The generation of the singular form is handled by the excellent inflect library. This approach has two main benefits: 1. It clearly distinguishes the target of the collection from the scalar helper methods. 2. It encourages sensible naming of collections (i.e. plural names). If inflect cannot find a singular form either because the attribute name was not plural, or the plural form is the same as the singular form, or the plural form overlaps with an existing attribute, then a suffix of _item will be used instead. If the resulting singular form overlaps with an existing attribute, a RuntimeError is raised and the user is invited to remedy the problem by renaming the attribute(s). By way of example, here are a few mappings: attribute name singular form numbers number children child errata erratum collection collection_item","title":"Method \"Singular\" Naming"},{"location":"usage/methods/collections/#mutable-sequences","text":"The helper method signatures for mutable sequences (including list ) are: with_<attr_singular>(_item, *, _index=MISSING, _insert=False, _inplace=False, _if=True) : Adds an element to the collection when _if is True . If _index is provided, the item at that index is replaced unless _insert is True in which case the new item is inserted before it. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_value_or_index, _new_item=MISSING, *, _by_index=MISSING, _inplace=False, _if=True) : Updates/replaces an element of the collection. Indexing semantics are as for transform_<attr_singular> below. transform_<attr_singular>(_value_or_index, _transform, *, _by_index=MISSING, _inplace=False, _if=True) : Transforms an element of the collection if _if is True . The item to be transformed is passed to the callable _transform , and is: if _by_index is False , the first instance of _value_or_index in the collection. if _by_index is True , the item at index _value_or_index . If _by_index is not specified, it defaults to True if _value_or_index is not of the same type as as that contained in the sequence. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. - without_<attr_singular>(_value_or_index, *, _by_index: bool = False, _inplace: bool = False, _if=True) : Removes an element from the collection if _if is True . The item to be removed is: if _by_index is False , the first instance of _value_or_index in the collection. if _by_index is True , the item at index _value_or_index . If _by_index is not specified, it defaults to True if _value_or_index is not of the same type as as that contained in the sequence. If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class FavoriteNumbers : numbers : List [ int ] = [] assert FavoriteNumbers () . with_number ( 10 ) . without_number ( 10 ) . numbers == []","title":"Mutable Sequences"},{"location":"usage/methods/collections/#mutable-mappings","text":"The helper method signatures for mutable mappings (including dict ) are: with_<attr_singular>(_key, _value, *, _inplace=False, _if=True) : Adds an element to the collection when _if is True by setting the value assigned to key _key to value _value . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_key, _new_item=MISSING, *, _inplace=False, _if=True) : Updates/replaces an element of the collection when _if is True .If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. transform_<attr_singular>(_key, _transform, *, _inplace=False, _if=True) : Transforms the value associated with key _key by passing it through the callable _transform when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. without_<attr_singular>(_key, *, _inplace: bool = False, _if=True) : Removes the mapping for _key from the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class ExaminationScores : scores : Dict [ str , float ] = {} assert ( ExaminationScores () . with_score ( \"Peter\" , 10.1 ) . with_score ( \"Justine\" , 13.3 ) . without_score ( \"Peter\" ) . scores ) == { 'Peter' : 10.1 }","title":"Mutable Mappings"},{"location":"usage/methods/collections/#mutable-sets","text":"The helper method signatures for mutable sets (including set ) are: with_<attr_singular>(_item, *, _inplace=False, _if=True) : Adds the nominated element _item to the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. update_<attr_singular>(_item, _new_item=MISSING, *, _inplace=False, _if=True) : Updates/replaces an element of the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. transform_<attr_singular>(_item, _transform, *, _inplace=False, _if=True) : Transforms the nominated _item by passing it through the callable _transform when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. without_<attr_singular>(_item, *, _inplace: bool = False, _if=True) : Removes _item from the collection when _if is True . If _inplace is True then the current instance is mutated, otherwise the mutation happens on a copy. @spec_class class FavoriteNumbers : numbers : Set [ int ] assert ( FavoriteNumbers () . with_number ( 1 ) . with_number ( 2 ) . transform_number ( 1 , lambda x : x + 1 ) . without_number ( 2 ) . numbers ) == set ()","title":"Mutable Sets"},{"location":"usage/methods/collections/#extensions-for-spec-class-types","text":"Just as for the scalar methods, if the item stored within any of the collections above is a spec-class, then the .with_<attr_singular>() and .transform_<attr_singular>() method signatures are extended with to allow direct mutation of the attributes of the nested spec classes. The following example is for sequence containers but the logic is the same for all collections. @spec_class class Box : label : str items : List [ str ] children : List [ \"Box\" ] help ( Box () . with_child ) # with_child(_item: __main__.Box = MISSING, *, _index: int = MISSING, _insert: bool = False, _inplace: bool = False, _if: bool = True, label: str = None, items: List[str] = None, children: List[__main__.Box] = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with an item added to or updated in `children`. # # Args: # _item: A new `Box` instance for children. # _index: Index for which to insert or replace, depending on `insert`; # if not provided, append. # _insert: Insert item before children[index], otherwise replace this # index. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # label: An optional new value for `child.label`. # items: An optional new value for `child.items`. # children: An optional new value for `child.children`. # Returns: # A reference to the mutated `Box` instance. help ( Box () . transform_child ) # transform_child(_value_or_index: Union[__main__.Box, int], _transform: Callable = MISSING, *, _by_index: bool = MISSING, _inplace: bool = False, _if: bool = True, label: str = None, items: List[str] = None, childre # n: List[__main__.Box] = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with an item transformed in `children`. # # Args: # _value_or_index: The value to transform, or (if `by_index=True`) its # index. # _transform: A function that takes the old item as input, and returns # the new item. # _by_index: If True, value_or_index is the index of the item to # transform. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # label: An optional transformer for `child.label`. # items: An optional transformer for `child.items`. # children: An optional transformer for `child.children`. # Returns: # A reference to the mutated `Box` instance.","title":"Extensions for spec-class types"},{"location":"usage/methods/scalars/","text":"Every attributed managed by spec-classes is furnished with generated scalar helper methods that simplify incremental mutation of the attributes and adoption of a copy-on-write workflow. The methods and their signatures are: with_<attr>(_new_value, *, _inplace=False, _if=True) : Sets <attr> to _new_value if _if is True . If _inplace is True , then the value is mutated on the current instance. update_<attr>(_new_value, *, _inplace=False, _if=True) : Updates an instance (this differs from with_<attr> in that spec-classes will be incrementally updated rather than replaced by this method). transform_<attr>(_new_value, *, _inplace=False, _if=True) : If _if is True , applies a function to the current value of <attr> , stores the result as the new value for <attr> on a copy of the spec class instance. If _inplace is True , then the value is mutated on the current instance. reset_<attr>(_new_value, *, _inplace=False, _if=True) : Resets the attribute back to the default value provided by the class (or MISSING if there is no default), if _if is True . If _inplace is True , then the value is mutated on the current instance. For example: @spec_class class Box : width : float height : float depth : float color : str = 'blue' @property def volume ( self ): return self . width * self . height * self . depth box = Box ( color = 'red' ) box # Box(width=MISSING, height=MISSING, depth=MISSING, color='red') box_modified = box . with_width ( 10. ) . with_height ( 10. ) . with_depth ( 10. ) box_modified # Box(width=10.0, height=10.0, depth=10.0, color='red') box_modified . volume # 1000.0 box_modified . transform_width ( lambda width : width * 2 ) . volume # 2000.0 box_modified . reset_color () . color # 'blue' assert box is not box_modified box_modified2 = box . with_width ( 10. , _inplace = True ) . with_height ( 10. , _inplace = True ) . with_depth ( 10. , _inplace = True ) assert box is box_modified2 Extensions for spec-class attributes \u00b6 When the type of the attribute being mutated by these utility methods is also a spec class, the with_<attr> and transform_<attr> methods above are extended to allow direct mutation of the attributes of the nested spec class. For example: @spec_class class Box : width : float height : float depth : float color : str nested_box : \"Box\" help ( Box () . with_nested_box ) # with_nested_box(_new_value: __main__.Box = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = None, height: float = None, depth: float = None, color: str = None, nested_box: __main__.Box = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes mutated. # # Args: # _new_value: The new value for `nested_box`. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional new value for nested_box.width. # height: An optional new value for nested_box.height. # depth: An optional new value for nested_box.depth. # color: An optional new value for nested_box.color. # nested_box: An optional new value for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. help ( Box () . update_nested_box ) # update_nested_box(_new_value: Callable = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = MISSING, height: float = MISSING, depth: float = MISSING, color: str = MISSING, nested_box: __main__.Box = MISSING) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes updated. # # Args: # _new_value: An optional value to replace the old value for # `nested_box`. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional new value for nested_box.width. # height: An optional new value for nested_box.height. # depth: An optional new value for nested_box.depth. # color: An optional new value for nested_box.color. # nested_box: An optional new value for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. help ( Box () . transform_nested_box ) # transform_nested_box(_transform: Callable = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = None, height: float = None, depth: float = None, color: str = None, nested_box: __main__.Box = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes transformed. # # Args: # _transform: A function that takes the old value for nested_box as # input, and returns the new value. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional transformer for nested_box.width. # height: An optional transformer for nested_box.height. # depth: An optional transformer for nested_box.depth. # color: An optional transformer for nested_box.color. # nested_box: An optional transformer for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. ( Box () . with_nested_box ( width = 10. , height = 10. , depth = 10. , color = 'red' ) . update_nested_box ( width = 30. ) # Using `with_nested_box` instead would reset other properties to their default values. ) # Box( # width=MISSING, # height=MISSING, # depth=MISSING, # color=MISSING, # nested_box=Box( # width=30.0, # height=10.0, # depth=10.0, # color='red', # nested_box=MISSING # ) # )","title":"Scalar Methods"},{"location":"usage/methods/scalars/#extensions-for-spec-class-attributes","text":"When the type of the attribute being mutated by these utility methods is also a spec class, the with_<attr> and transform_<attr> methods above are extended to allow direct mutation of the attributes of the nested spec class. For example: @spec_class class Box : width : float height : float depth : float color : str nested_box : \"Box\" help ( Box () . with_nested_box ) # with_nested_box(_new_value: __main__.Box = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = None, height: float = None, depth: float = None, color: str = None, nested_box: __main__.Box = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes mutated. # # Args: # _new_value: The new value for `nested_box`. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional new value for nested_box.width. # height: An optional new value for nested_box.height. # depth: An optional new value for nested_box.depth. # color: An optional new value for nested_box.color. # nested_box: An optional new value for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. help ( Box () . update_nested_box ) # update_nested_box(_new_value: Callable = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = MISSING, height: float = MISSING, depth: float = MISSING, color: str = MISSING, nested_box: __main__.Box = MISSING) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes updated. # # Args: # _new_value: An optional value to replace the old value for # `nested_box`. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional new value for nested_box.width. # height: An optional new value for nested_box.height. # depth: An optional new value for nested_box.depth. # color: An optional new value for nested_box.color. # nested_box: An optional new value for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. help ( Box () . transform_nested_box ) # transform_nested_box(_transform: Callable = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = None, height: float = None, depth: float = None, color: str = None, nested_box: __main__.Box = None) method of __main__.Box instance # Return a `Box` instance identical to this one except with `nested_box` or its attributes transformed. # # Args: # _transform: A function that takes the old value for nested_box as # input, and returns the new value. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional transformer for nested_box.width. # height: An optional transformer for nested_box.height. # depth: An optional transformer for nested_box.depth. # color: An optional transformer for nested_box.color. # nested_box: An optional transformer for nested_box.nested_box. # Returns: # A reference to the mutated `Box` instance. ( Box () . with_nested_box ( width = 10. , height = 10. , depth = 10. , color = 'red' ) . update_nested_box ( width = 30. ) # Using `with_nested_box` instead would reset other properties to their default values. ) # Box( # width=MISSING, # height=MISSING, # depth=MISSING, # color=MISSING, # nested_box=Box( # width=30.0, # height=10.0, # depth=10.0, # color='red', # nested_box=MISSING # ) # )","title":"Extensions for spec-class attributes"},{"location":"usage/methods/toplevel/","text":"Spec-classes are furnished with several high-level mutation methods that simplify (and allow chaining) of copy-on-write mutations. They are: update(_new_value, *, _inplace=False, _if=True, **<spec-attributes>) : Returns _new_value and/or an instance with the nominated attribute values mutated. transform(_transform, *, _inplace=False, _if=True, **<transforms for attributes>) : Returns the output of _transform(<spec_class_instance>) if _transform is supplied, and/or with its attributes mutated if they are passed via kwargs. reset(*, _inplace=False, _if=True) : Resets all spec-class attributes to their default values. For example: @spec_class class Box : width : float height : float depth : float color : str = 'blue' @property def volume ( self ): return self . width * self . height * self . depth box = Box ( color = 'red' ) box # Box(width=MISSING, height=MISSING, depth=MISSING, color='red') box_modified = box . update ( width = 10. , height = 10. , depth = 10. ) box_modified # Box(width=10.0, height=10.0, depth=10.0, color='red') box_modified . volume # 1000.0 box_modified . transform ( width = lambda width : width * 2 ) . volume # 2000.0 box_modified . reset () . color # 'blue' assert box is not box_modified box_modified2 = box . update ( width = 10. , height = 10. , depth = 10. , _inplace = True ) assert box is box_modified2 As with all spec-class methods, you can look up their documentation: help ( Box () . update ) # update(_new_value: __main__.Box = MISSING, *, _inplace: bool = False, _if: bool = True, width: float = MISSING, height: float = MISSING, depth: float = MISSING, color: str = 'blue') method of __main__.Box instance # Return `_new_value`, or an `Box` instance identical to this one except with nominated attributes mutated. # Args: # _new_value: A complete replacement for this instance. # _inplace: Whether to perform change without first copying. # _if: This action is only taken when `_if` is `True`. If it is `False`, # this is a no-op. # width: An optional new value for Box.width. # height: An optional new value for Box.height. # depth: An optional new value for Box.depth. # color: An optional new value for Box.color. # Returns: # `_new_value` or a reference to the mutated `Box` instance.","title":"Toplevel Methods"}]}